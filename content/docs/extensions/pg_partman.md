---
title: The pg_partman extension
subtitle: Manage large Postgres tables using PostgreSQL Partition Manager
enableTableOfContents: true
updatedOn: '2024-03-17T20:32:29.796Z'
---

`pg_partman` is a Postgres extension to simplify management of partitioned tables.  

Partitioning refers to splitting a single table into smaller pieces called `partitions`. This is done based on the values in a key column or set of columns. Partitions are stored as separate physical tables, but the partitioned table can still be queried as a single logical table. This can significantly enhance query performance and also help you manage the lifecycle of data in tables that grow very large.

While Postgres natively supports partitioning, `pg_partman` helps set up and manage partitioned tables, by automating steps like creation of new partitions and handle data lifecycle given the retention policy. 

<CTA />

In this guide, weâ€™ll learn how to set up and use the `pg_partman` extension within your Neon Postgres project. We'll cover why is partitioning helpful, how to enable `pg_partman`, creating partitioned tables, and automating partition maintenance. 

<Admonition type="note">
    `pg_partman` is an open-source for Postgres that can be installed in any Neon project, using the instructions below. Detailed installation instructions and compatibility information can be found at [pg_partman Documentation](https://github.com/pgpartman/pg_partman).
</Admonition>

**Version Compatibility:**

`pg_partman` works with PostgreSQL 14 and above, complementing the native partitioning features introduced in these versions. The exact version of `pg_partman` available in Neon depends on the version of Postgres you select for your Neon project.

[TODO: add version information](https://neon.tech/docs/extensions/pg-extensions)

## Enable the `pg_partman` extension

You can enable the extension by running the following `CREATE EXTENSION` statement in the Neon **SQL Editor** or from a client such as `psql` that is connected to Neon.

```sql
CREATE EXTENSION IF NOT EXISTS pg_partman;
```

For information about using the Neon SQL Editor, see [Query with Neon's SQL Editor](/docs/get-started-with-neon/query-with-neon-sql-editor). For information about using the `psql` client with Neon, see [Connect with psql](/docs/connect/query-with-psql-editor). 

## Why Partition Your Data?

For a table that might grow really large, partitioning it offers a few benefits:

- **Faster queries:** Partitioning allows PostgreSQL to quickly locate and retrieve data within a specific partition, rather than scanning the entire table. 
- **Managing Data Lifecycle:** Easier management of data lifecycle by archiving or purging old partitions, which can be moved to cheaper storage options without affecting the active dataset.
- **Scalability:** Partioning makes database administration simpler. For example, smaller partitions are easier to load and delete, or back up and recover, compared to running a bulk query on the full table.

## Native partitioning vs pg_partman

Postgres supports partitioning tables natively, with the following strategies to divide the data:

- List partitioning: Data is distributed across partitions based on a list of values, such as a category or location. 
- Range partitioning: Data is distributed across partitions based on ranges of values, such as dates or numerical ranges.

With native partitoning, you need to manually create and manage partitions for your table. 

```sql
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
) PARTITION BY RANGE (logdate);

-- Create a partition for each month of logged data
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');

-- Moving older data to a different table
ALTER TABLE measurement DETACH PARTITION measurement_y2005m10;
```

`pg_partman` only supports creating partitions that are number/time-based. 

## Example: partitioning user-activity data

Consider a social media platform that tracks user interactions on their website/app, such as likes, comments, and shares. The data is stored in a table called `user_activity`, where `activity_type` could store the type of activity and details could store additional JSON-formatted information about it. 

### Set up partitioned table

Given the large volume of data generated by user interactions, partitioning the `user_activities` table can help keep queries tractable. Recent activity data is typically the most interesting for both the platform and its users, so `activity_time` is a good candidate to partition on. 

```sql
CREATE TABLE user_activities (
    activity_id serial PRIMARY KEY,
    activity_time TIMESTAMPTZ NOT NULL,
    activity_type TEXT NOT NULL,
    content_id INT NOT NULL,
    user_id INT NOT NULL,
    details JSONB
);
PARTITION BY RANGE (activity_time);
```

To create a partition for each week of activity data, you can run the following query:

```sql
SELECT partman.create_parent('public.user_activities', 'activity_time', 'weekly');
```

This will create a new partition for each week of data in the `user_activities` table. The background worker process that comes bundled with `pg_partman` will automatically create new partitions as more data is inserted in the future. 

To make sure that old data is automatically removed from the main table, you can set up a retention policy:

```sql
UPDATE partman.part_config 
SET retention = '4 weeks', retention_keep_table = true
WHERE parent_table = 'public.user_activities';
```

`pg_partman` will automatically detach the old partitions that are older than 4 weeks from the main table. Since, we've set `retention_keep_table` to `true`, the old partitions will be kept as separate tables, and not dropped from the database. 

#### Sub-partitioning by Device ID

For a more granular organization, suppose we want to sub-partition the data by `device_id`. This requires a custom partitioning strategy:

```sql
SELECT partman.create_sub_parent('public.device_data_device_id', 'list');
```

This command sets up sub-partitioning under each time-based partition, organizing data by `device_id`. It assumes a more complex setup and might require additional steps for implementation, as `pg_partman` primarily focuses on automating time and serial-based partitions. However, it showcases the potential for highly organized data structures.

### Automating and Optimizing Partition Management

`pg_partman` excels in automating partition management tasks. Beyond the automatic creation of future partitions, it includes features for:

- **Automatic Partition Data Retention:** Easily configure the retention of data, automatically purging old partitions beyond a certain age to manage data lifecycle efficiently.
  
  ```sql
  SELECT partman.drop_partition_time('public.device_data', p_keep_table := false, p_retention := '12 months');
  ```

  This command configures `device_data` to retain 12 months of data, automatically dropping older partitions.

- **Partition Maintenance:** The `run_maintenance` function is pivotal in `pg_partman`'s operation, handling the creation and purging of partitions based on the configurations provided. It can be scheduled as a background job, ensuring partitions are always optimized without manual intervention.

  ```sql
  SELECT partman.run_maintenance(p_analyze := true, p_jobmon := true);
  ```

  This maintenance operation can be scheduled (e.g., via `pg_cron` or an external cron job) and includes options for database statistics analysis (`p_analyze`) and monitoring job execution (`p_jobmon`).

### Advanced Data Management Strategies

With the vast amount of data collected from IoT devices, `pg_partman` also supports:

- **Partitioning by ID Range:** Useful for datasets where range partitioning by time isn't applicable. You can partition data based on numerical ID ranges, optimizing access patterns for non-temporal queries.

- **Dynamic Background Worker:** Utilize PostgreSQL's background workers to automate `pg_partman` tasks without relying on external schedulers, enhancing the database's ability to self-manage partitioning operations.

- **Template Tables:** Define a template table to specify custom settings, indexes, and constraints that every new partition should inherit. This ensures consistency and performance optimizations are maintained across all partitions.

### Conclusion

By leveraging `pg_partman`, you can significantly enhance PostgreSQL's native partitioning functionality, particularly for complex datasets like those generated by IoT devices. The extension simplifies partition management, automates tedious tasks, and provides advanced features for comprehensive data organization and retention strategies. With `pg_partman`, databases handling large-scale, time-series, or IoT data can achieve improved performance, easier maintenance, and optimal data lifecycle management.

## Reference

- [pg_partman Documentation](https://github.com/pgpartman/pg_partman)
- [PostgreSQL Partitioning Documentation](https://www.postgresql.org/docs/current/ddl-partitioning.html)