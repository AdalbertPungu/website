---
title: The pg_partman extension
subtitle: Manage large Postgres tables using the PostgresQL Partition Manager extension
enableTableOfContents: true
updatedOn: '2024-03-17T20:32:29.796Z'
---

`pg_partman` is a Postgres extension to simplify management of partitioned tables. Partitioning refers to splitting a single table into smaller pieces called `partitions`. This is done based on the values in a key column or set of columns. Even though partitions are stored as separate physical tables, the partitioned table can still be queried as a single logical table. This can significantly enhance query performance and also help you manage the lifecycle of data in tables that grow very large.

While Postgres natively supports partitioning, `pg_partman` helps set up and manage partitioned tables, by automating steps like creation of new partitions and handle data lifecycle given the retention policy. 

<CTA />

In this guide, weâ€™ll learn how to set up and use the `pg_partman` extension within your Neon Postgres project. We'll cover why is partitioning helpful, how to enable `pg_partman`, creating partitioned tables, and automating partition maintenance. 

<Admonition type="note">
    `pg_partman` is an open-source for Postgres that can be installed in any Neon project, using the instructions below. Detailed installation instructions and compatibility information can be found at [pg_partman Documentation](https://github.com/pgpartman/pg_partman).
</Admonition>

## Enable the `pg_partman` extension

You can enable the extension by running the following `CREATE EXTENSION` statement in the Neon **SQL Editor** or from a client such as `psql` that is connected to Neon.

```sql
CREATE EXTENSION IF NOT EXISTS pg_partman;
```

For information about using the Neon SQL Editor, see [Query with Neon's SQL Editor](/docs/get-started-with-neon/query-with-neon-sql-editor). For information about using the `psql` client with Neon, see [Connect with psql](/docs/connect/query-with-psql-editor). 

**Version Compatibility:**

`pg_partman` works with PostgreSQL 14 and above, complementing the native partitioning features introduced in these versions. The exact version of `pg_partman` available in Neon depends on the version of Postgres you select for your Neon project.

[TODO: add version information](https://neon.tech/docs/extensions/pg-extensions)

## Why Partition Your Data?

For a table that might grow really large, partitioning it offers a few benefits:

- **Faster queries:** Partitioning allows PostgreSQL to quickly locate and retrieve data within a specific partition, rather than scanning the entire table. 
- **Scalability:** Partioning makes database administration simpler. For example, smaller partitions are easier to load and delete, or back up and recover, compared to running a bulk query on the full table.
- **Managing Data Lifecycle:** Easier management of data lifecycle by archiving or purging old partitions, which can be moved to cheaper storage options without affecting the active dataset.

### Native partitioning vs pg_partman

Postgres supports partitioning tables natively, with the following strategies to divide the data:

- List partitioning: Data is distributed across partitions based on a list of values, such as a category or location. 
- Range partitioning: Data is distributed across partitions based on ranges of values, such as dates or numerical ranges.

With native partitoning, you need to manually create and manage partitions for your table. 

```sql
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
) PARTITION BY RANGE (logdate);

-- Create a partition for each month of logged data
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');

-- Moving older data to a different table
ALTER TABLE measurement DETACH PARTITION measurement_y2005m10;
```

`pg_partman` only supports creating partitions that are number/time-based, each partition covering a range of values. However, it simplifies the process of creating and managing partitions. 

## Example: partitioning user-activity data

Consider a social media platform that tracks user interactions on their website/app, such as likes, comments, and shares. The data is stored in a table called `user_activity`, where `activity_type` could store the type of activity and details could store additional JSON-formatted information about it. 

### Set up partitioned table

Given the large volume of data generated by user interactions, partitioning the `user_activities` table can help keep queries tractable. Recent activity data is typically the most interesting for both the platform and its users, so `activity_time` is a good candidate to partition on. 

```sql
CREATE TABLE user_activities (
    activity_id serial,
    activity_time TIMESTAMPTZ NOT NULL,
    activity_type TEXT NOT NULL,
    content_id INT NOT NULL,
    user_id INT NOT NULL
)
PARTITION BY RANGE (activity_time);
```

To create a partition for each week of activity data, you can run the following query:

```sql
SELECT partman.create_parent('public.user_activities', 'activity_time', '1 week');
```

This will create a new partition for each week of data in the `user_activities` table. We can insert some sample data into the table:

```sql
INSERT INTO user_activities (activity_time, activity_type, content_id, user_id)
VALUES
    ('2024-03-15 10:00:00', 'like', 1001, 101),
    ('2024-03-16 15:30:00', 'comment', 1002, 102),
    ('2024-03-17 09:45:00', 'share', 1003, 103),
    ('2024-03-18 18:20:00', 'like', 1004, 104),
    ('2024-03-19 12:10:00', 'comment', 1005, 105),
    ('2024-03-20 08:00:00', 'like', 1006, 106),
    ('2024-03-21 14:15:00', 'share', 1007, 107),
    ('2024-03-22 11:30:00', 'like', 1008, 108),
    ('2024-03-23 16:45:00', 'comment', 1009, 109),
    ('2024-03-24 20:00:00', 'share', 1010, 110),
    ('2024-03-25 09:30:00', 'like', 1011, 111),
    ('2024-03-26 13:45:00', 'comment', 1012, 112),
    ('2024-03-27 17:00:00', 'share', 1013, 113),
    ('2024-03-28 11:15:00', 'like', 1014, 114),
    ('2024-03-29 15:30:00', 'comment', 1015, 115);
```

### Querying partitioned table

We can query against the `user_activities` table as if it were a single table, and Postgres will automatically route the query to the correct partition(s) based on the `activity_time` column. 

```text
neondb=> SELECT * FROM user_activities WHERE activity_time BETWEEN '2024-03-20' AND '2024-03-25';
 activity_id |     activity_time      | activity_type | content_id | user_id
-------------+------------------------+---------------+------------+---------
          16 | 2024-03-20 08:00:00+00 | like          |       1006 |     106
          17 | 2024-03-21 14:15:00+00 | share         |       1007 |     107
          18 | 2024-03-22 11:30:00+00 | like          |       1008 |     108
          19 | 2024-03-23 16:45:00+00 | comment       |       1009 |     109
          20 | 2024-03-24 20:00:00+00 | share         |       1010 |     110
(5 rows)
```

To see the list of all partitions created for the `user_activities` table, you can run the following query:

```text
neondb=> SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name LIKE 'user_activities_%';
        table_name
---------------------------
 user_activities_p20240329
 user_activities_p20240405
 user_activities_p20240315
 user_activities_p20240322
 user_activities_p20240412
 user_activities_p20240419
 user_activities_p20240426
 user_activities_default
 user_activities_p20240301
 user_activities_p20240308
(10 rows)
```

`pg_partman` automatically created tables for weekly intervals close to the current data. As more data is inserted in the future, it will create new partitions for them. Additionally, there is a `user_activities_default` table that stores data that doesn't fit into any of the existing partitions. 

### Data Retention Policy

To make sure that old data is automatically removed from the main table, you can set up a retention policy:

```sql
UPDATE partman.part_config 
SET retention = '4 weeks', retention_keep_table = true
WHERE parent_table = 'public.user_activities';
```

The background worker process that comes bundled with  `pg_partman` will automatically detach the old partitions that are older than 4 weeks from the main table. Since, we've set `retention_keep_table` to `true`, the old partitions will be kept as separate tables, and not dropped from the database. 

## Conclusion

By leveraging `pg_partman`, you can significantly enhance PostgreSQL's native partitioning functionality, particularly for large-scale and time-series datasets. The extension simplifies partition management, automates retention/archival tasks, and improves query performance. 

## Reference

- [pg_partman Documentation](https://github.com/pgpartman/pg_partman)
- [PostgreSQL Partitioning Documentation](https://www.postgresql.org/docs/current/ddl-partitioning.html)