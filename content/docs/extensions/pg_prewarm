---
title: The pg_prewarm extension
subtitle: load data into Postgres shared buffers with the pg_prewarm extension
enableTableOfContents: true
updatedOn: '2024-01-28T13:46:59.387Z'
---

You can use the `pg_prewarm` extension to preload table and index data into the Postgres buffer cache after your Postgres instance has been restarted. Doing so can help improve query response times after restarting your Postgres instance by ensuring that your data is readily available in memory. Otherwise, you may experience slower query response times after a restart, as the system will need to reload data into the buffer cache from disk on-demand, which can be time consuming.

<CTA />

In this guide, we'll explore the `pg_prewarm` extension, how to enable it, and how to use it to prewarm your Postgres buffer cache. 

<Admonition type="note">
The `pg_prewarm` extension is open-source and can be installed on any Postgres setup. Detailed information about the extension is available in the [PostgreSQL Documentation](https://www.postgresql.org/docs/current/pgprewarm.html).
</Admonition>

**Version availability**

Please refer to the [list of all extensions](https://neon.tech/docs/extensions/pg-extensions) available in Neon for up-to-date version information for the `pg_prewarm` extension. 

## Enable the `pg_prewarm` extension

Enable the `pg_prewarm` by running the `CREATE EXTENSION` statement in your Postgres client:

```sql
CREATE EXTENSION IF NOT EXISTS pg_prewarm;
```

For information about using the Neon SQL Editor, see [Query with Neon's SQL Editor](/docs/get-started-with-neon/query-with-neon-sql-editor). For information about using the `psql` client with Neon, see [Connect with psql](/docs/connect/query-with-psql-editor). 

## Example usage

This section provides `pg_prewarm` usage exmaples, demonstrating basic and advanced usage scenarios.

## Basic usage

To prewarm a specific table, simply use the `pg_prewarm` function with the name of the table you want to cache.

```sql
SELECT pg_prewarm('table_or_index_name');
```

Replace 'table_or_index_name' with the actual name of your table or index.

The output of a `SELECT pg_prewarm()` query is a count of blocks from the specified table or index that were loaded into the Postgres buffer cache. The default block size in Postgres is 8192 bytes (8KB). You can use this information to quickly calculate how much data was loaded into your buffer cache. For an example, see [Check the proportion of a table loaded into cache](#check-the-proportion-of-a-table-loaded-into-cache).

The `pg_prewarm` function does not support specifying multiple table or index names in a single command. It's designed to work with a single table or index at a time. If you want to prewarm multiple tables or index, you would need to call `pg_prewarm` separately for each.

## Running pg_prewarm on indexes

Running `pg_prewarm` on an index is similar to running it on a table, but you specify the index's OID (Object Identifier) or its fully qualified name (schema name plus index name) instead. The `pg_prewarm` function can preload table data or index blocks into the PostgreSQL buffer cache, improving query performance by reducing disk I/O for frequently accessed data.

Here's an example SQL statement that demonstrates how to use pg_prewarm to preload a specific index into memory:

```sql
SELECT pg_prewarm('schema_name.index_name');
```

Replace `schema_name.index_name`with the actual schema and index name you want to prewarm. If you're not sure about the index name or want to list all indexes for a specific table, you can use the `pg_indexes` view to find out. Here's how you might query for index names:

```sql
SELECT indexname FROM pg_indexes WHERE tablename = 'your_table_name';
```
Replace 'your_table_name' with the name of the table whose indexes you're interested in. Once you have the index name, you can then use `pg_prewarm` as shown above.

Additionally, if you prefer to use the index's OID, you can find it using the `pg_class` system catalog. Here's how to find an index's OID:

```sql
SELECT oid FROM pg_class WHERE relname = 'index_name';
```

Then, you can use the OID with pg_prewarm like so:

```sql
SELECT pg_prewarm(your_index_oid);
```

## Check the proportion of a table loaded into cache

In this example, we'll create a table, check its data size, run `pg_prewarm`, and then check to see what proprtion of the table was laoded into the buffer cache.

1. First, create a table and populate it with some data:

    ```sql
    CREATE TABLE t_test AS
    SELECT * FROM generate_series(1, 1000000) AS id;
    ```

2. Check the size of the table:

    ```sql
    SELECT pg_size_pretty(pg_relation_size('t_test')) AS table_size_pretty,
        pg_relation_size('t_test') AS table_size_bytes;
    ```

    This command returns the size of the table in both MB and bytes.

    ```sql
     table_size_pretty | table_size_bytes 
    -------------------+------------------
    35 MB              |         36700160
    ```

3. Load the table data into the Postgres buffer cache using `pg_prewarm`:

    ```sql
    SELECT pg_prewarm('public.t_test') AS blocks_loaded;
    ```

    This will output the number of blocks that were loaded into the cache:

    ```sql
    blocks_loaded 
    ---------------
            4480
    ```

4. To understand the calculation that follows, check the block size of your Postgres instance:

    ```sql
    SHOW block_size;
    ```

    The default block size in Postgres is 8192 bytes (8KB). We'll use this value in the next step.

    ```sql
    block_size 
    ------------
    8192
    ```

5. Calculate the total size of the data loaded into cache using the block size and the number of blocks loaded:

    ```sql
    -- Assuming 4480 blocks were loaded (replace with your actual number from pg_prewarm output)
    SELECT 4480 * 8192 AS loaded_data_bytes;
    ```

    You can now compare this value with the size of your table.

    ```sql
     loaded_data_bytes 
    -------------------
            36700160
    ```

    The values for the size of the table and the size of the data loaded into the buffer cache as shown in your example match exactly, which is an ideal scenario. However, there are cases where these values might not match, indicating that not all the data was loaded into the buffer cache. These are some situations where the values might not match up:
    - Partial prewarming: If pg_prewarm only partially loads the table into the buffer cache due to constraints like memory availability. This can happen if the system doesn't have enough free memory in the buffer cache to hold the entire table.
    - TOASTed Data: PostgreSQL uses a mechanism called TOAST (The Oversized-Attribute Storage Technique) to store large attributes of a table out of line. If your table contains large data types (like text or bytea) that are compressed and stored out of the main table area, the size calculation might not directly match because `pg_prewarm` might not effectively prewarm these out-of-line, compressed data portions.
    - Concurrent modifications: If the table is being modified (inserts, updates, deletes) while the prewarming process is happening or between the size check and the prewarming operation, this could lead to discrepancies. The actual data size in the table might change between the time it's measured and the time pg_prewarm runs or completes.
    - Index data: The exmaple shown above does not include indexes that might be associated with the table. `pg_prewarm` can also prewarm indexes, but if you're only looking at the table's data size, any loaded index data won't be accounted for in this comparison.
    - Overhead and metadata: There are internal overheads and metadata associated with Postgres data storage that might not be directly proportional to the block size times the number of blocks. This can slightly affect the calculations.

## Demonstrating the effect of pg_prewarm

1. Create two identical sample tables for comparison:

    ```sql
    CREATE TABLE tbl_Transactions_1
    (
        TranID SERIAL,
        TransactionDate TIMESTAMPTZ,
        TransactionName TEXT
    );

    INSERT INTO tbl_Transactions_1
    (TransactionDate, TransactionName)
    SELECT x, 'dbrnd' 
    FROM generate_series('2010-01-01 00:00:00'::timestamptz, '2018-02-01 00:00:00'::timestamptz, '1 minutes'::interval) a(x);
    ```

    ```sql
    CREATE TABLE tbl_Transactions_2
    (
        TranID SERIAL,
        TransactionDate TIMESTAMPTZ,
        TransactionName TEXT
    );

    INSERT INTO tbl_Transactions_2
    (TransactionDate, TransactionName)
    SELECT x, 'dbrnd' 
    FROM generate_series('2010-01-01 00:00:00'::timestamptz, '2018-02-01 00:00:00'::timestamptz, '1 minutes'::interval) a(x);
    ```

2. Prewarm the first sample table:

    ```sql
    SELECT pg_prewarm('tbl_Transactions_1');
    ```

3. Check the executions plans for both tables.

    Compare the execution plan of the prewarmed table vs. a non-prewarmed table to see the performance improvement.

    ```sql
    EXPLAIN ANALYZE SELECT * FROM tbl_Transactions_1;
    ```

    ```sql
    EXPLAIN ANALYZE SELECT * FROM tbl_Transactions_2;
    ```

    The execution time for the prewarmed table should be significantly lower than for the table that has not been prewarmed.

## Advanced parameters

`pg_prewarm` offers additional parameters for more control over what is prewarmed. For example, you can specify which parts of the table to cache, such as the main data file, the visibility map (VM), or the free space map (FSM).

```sql
SELECT pg_prewarm('your_table_name', 'buffer', 'main', first_block, last_block);
```

Beyond simply preloading an entire table, `pg_prewarm` offers additional parameters to give users more control over precisely what parts of a table are loaded into the cache. Here's a breakdown of these parameters and what they control:

- `regclass` (Table Name or index name): This is the first and mandatory parameter, where you specify the name of the table or index you want to prewarm. It's provided as a `regclass`, which is a way PostgreSQL references table names internally.
- `mode`: This optional parameter defines how the prewarming should be done. It can take these values:
    - `'buffer'`: This mode loads the specified table blocks directly into PostgreSQL's shared buffers.
    - `'pread'`: This mode uses the pread system call to load the data into the operating system's cache but not into Postgres shared buffers. It can be useful for warming up the OS cache while avoiding the consumption of PostgreSQL buffer memory.
    - `'buffer'` is the default mode if none is specified.
    - `fork`: PostgreSQL tables can have multiple "forks" or physical components, and this parameter allows you to specify which part of the table you want to prewarm. The options include:
        - `'main'`: This is the main data file of the table where the actual data rows are stored. Preloading the main fork is most common and usually what you want for performance improvements.
        - `'fsm'`: Stands for Free Space Map. It tracks the available space in the table for future inserts or updates. Preloading the FSM can be useful for operations that heavily involve data modification, as it can speed up the process of finding free space.
        - `'vm'`: Stands for Visibility Map. It keeps track of which rows are visible to which transactions, aiding in the efficiency of index-only scans and vacuum operations. Preloading the VM can be beneficial for read-heavy workloads with frequent index-only scans.
        - `first_block`: An optional parameter specifying the first block of the table's fork to preload. If not set, prewarming starts from the first block.
        - `last_block`: Similar to first_block, this optional parameter defines the last block of the table's fork to preload. If not set, prewarming continues until the end of the table.

By using these parameters, you can fine-tune the prewarming process to match your application's specific access patterns and performance needs.

## Conclusion

Prewarming your table data and indexes can help improve read performance, especially after a database restart or for indexes that are not frequently used but will be involved in upcoming heavy read operations. However, it's essential to use this feature cuatiously, especially on systems with limited memory resources, to avoid potential negative impacts on overall performance.

## Resources

- [PostgreSQL pg_prewarm documentation](https://www.postgresql.org/docs/current/pgprewarm.html)

<NeedHelp/>
